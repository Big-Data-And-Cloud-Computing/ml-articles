<chapter title="A visual explanation of regularization for linear models"
	 author={[Terence Parr](http://parrt.cs.usfca.edu)}>

<section title="Introduction">

	*in progress*
	
ADD LINKS TO IMAGES
	
Linear and logistic regression models are important because they are interpretable, fast, and form the basis of deep learning neural networks.  They are also extremely simple; we're just fitting lines (or hyperplanes) through training data. Unfortunately, linear models have a tendency to chase outliers in the training data, which often leads to models that don't generalize well to new data. To produce models that generalize better, we all know to *regularize* our models.  There are many forms of regularization, such as *early stopping* and *dropout* for deep learning, but for isolated linear models, *Lasso* and *Ridge* regularization are most common. (We'll call Lasso *L1* and Ridge *L2* for reasons that will become clear later.)

My goal in this article is to provide a visual explanation for regularization of linear models and to identify the critical stumbling block that makes it hard to understand how regularization works. Here it is upfront: **the math used to implement regularization does not correspond to the pictures everyone uses to explain regularization**. Take a look at the oft-copied picture on page 71 "Shrinkage Methods" from the excellent book *The Elements of Statistical Learning* (Hastie, Tibshirani, Friedman):

<img src="images/ESL_reg.png" width="40%">
	
Students see this multiple times in their careers but have trouble mapping that to the relatively straightforward mathematics used to regularize linear model training. The simple reason is that those graphs show how we  regularize models conceptually, with *hard constraints*, not how we actually implement regularization, with *soft constraints*! We'll go into that in detail shortly.  This single disconnect has no doubt caused untold amounts of consternation for those trying to deeply understand regularization. Read on to learn the real story.

I also want to answer key questions regarding L1 Lasso regularization: 

<ol>
<li> *Does L1 encourage model coefficients to shrink to zero or does it simply not discourage zeroes?* (**It encourages zeros.**)
<li> *If L1 encourages zero coefficients, why/how does it do that?!* (**The answer requires a picture, see below.**)
</ol>

These are not easy questions to answer in detail, even for mathematicians. Try explaining simply, without handwaving, to an inquisitive and persistent student; you'll find that you're not exactly sure. ;)

Regularization for linear and logistic regression is done through the same penalty term in the loss function and so I will focus on just linear regression in this article.

<section title="Review of linear regression">

I'm assuming that readers more or less understand the mathematics of linear models and how we find optimal model coefficients to fit lines, but let's take a minute to review the important equations so we're all on the same page. (My plan is to keep mathematics notation to a minimum in this article though.)

<sidefig caption="Best fit line through 10 sample data points with ordinary least squares regression." label="xyplot">	
<img src="images/ols.svg" width="80%">
</sidefig>

A single-variable linear regression model is familiar to us from high school algebra: $y = \beta_0 + \beta_1 x$, where (coefficient) $\beta_0$ is the $y$-intercept and $\beta_1$ is the slope of the line.  For example, let's say we have the following 10 training records and want to draw the *best fit* line through the points, as shown in [xyplot]. 

<pyeval label=reg hide=true output="df">
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.patches import Circle
import mpl_toolkits.mplot3d.art3d as art3d
from sklearn.linear_model import LinearRegression, Ridge, Lasso, LogisticRegression
np.set_printoptions(precision=2, suppress=True, linewidth=80)

df = pd.DataFrame(data=[[0.0,1.053880874257158],
[1.1111111111111112,1.6930723862524246],
[2.2222222222222223,-0.04867559455082526],
[3.3333333333333335,2.5201150366216343],
[4.444444444444445,4.978339964087746],
[5.555555555555555,5.78858680886268],
[6.666666666666667,7.023970174897514],
[7.777777777777779,6.026499123031133],
[8.88888888888889,9.58117222322382],
[10.0,10.762637572334718]], columns=['x','y'])
x = df['x'].values.reshape(-1,1)
y = df['y']
</pyeval>

The best fit line is $\hat{y} = -0.17 + 1.022x$, where we use $\hat{y}$ to indicate it is an approximation of the true underlying relationship between $x$ and $y$. Using Python and `sklearn`, it's trivial to fit a linear model to this data:

<pyeval label=reg>
lm = LinearRegression()        # Create a linear model
lm.fit(x, y)                   # Fit to x,y training data
</pyeval>

and get those optimal coefficients:

<pyeval label=reg>
optimal_beta0 = lm.intercept_
optimal_beta1 = lm.coef_[0]
y_pred = lm.predict(x)         # What does model predict for x? (orange line)
</pyeval>

<pyeval label=reg hide=true>
print(f"optimal_beta0 = {optimal_beta0:.3f}, optimal_beta1 = {optimal_beta1:.3f}")
print("y_pred", y_pred)
</pyeval>

The notion of *best fit* means choosing $\beta_0$ and $\beta_1$ to minimize the average error, the average difference between the known true $y^{(i)}$ values and the model predictions, $\hat{y}^{(i)}$.  To make things nice mathematically, and to avoid needing an absolute value operator, linear regression optimizes the average (mean) squared error.  That's where the term *Ordinary Least Squares* (OLS) comes from. The MSE function is a quadratic that always gives us a bowl shaped loss function, for 2 coefficients anyway, as shown in [ols3D].  For all $n$ training records $(x^{(i)},y^{(i)})$, we find $\beta_0,\beta_1$ to minimize:

\[
MSE(\beta_0,\beta_1) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - \hat{y}^{(i)})^2
\]

(If you're a `numpy` junkie, that is just `np.mean(y - m.predict(x))` for vectors `y` and `x`.) Plugging the model, our line equation, into that MSE we get:

\[
MSE(\beta_0,\beta_1) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - (\beta_0 + \beta_1 x^{(i)}))^2
\]

The loss function goes up as $\beta_0$ and $\beta_1$ move away from the bottom of the bowl. The big black dot represents the minimum loss location, $(\beta_0, \beta_1)$ = (-0.17, 1.022). (See [code/loss3d.py](code/loss3d.py) for the code.) Three-dimensional plots are sometimes hard to interpret on a two-dimensional screen, so you will often see the loss function projected down onto the $\beta_0$, $\beta_1$ plane, as shown in [ols2D] ([code/loss2d.py](code/loss2d.py)).

It's important to see the relationship between [xyplot] and [ols3D]. So, just to be clear, shifting $\beta_0$ and $\beta_1$ in [ols3D] causes the orange line in [xyplot] to tilt or move up and down, away from the best fit.



<sidefig caption="Loss function in 3D where the black dot shows the smallest loss, the bottom of the bowl." label="ols3D">	
	<img src="images/ols_loss_3D.svg" width="80%">
</sidefig>


<sidefig caption="Loss function contour projected onto 2D plane, as if we were looking from above." label="ols2D">	
	<img src="images/ols_loss_2D.svg" width="70%">
</sidefig>
	


<section title="Motivation">

So far so good.  Given some data, we can fit a best fit line through the data where "best fit" means the line that minimizes the average squared between true $y$ values and those predicted by the model. Now, let's tweak the last $y$ value to be about 10 times as big: 

<pyeval label=reg>
y.iloc[-1] = 100        # Make last y be an outlier 10x as big
lm = LinearRegression()
lm.fit(x, y)
y_pred = lm.predict(x)  # Get orange line points again
</pyeval>

<pyeval label=reg hide=true>
optimal_beta0 = lm.intercept_
optimal_beta1 = lm.coef_[0]
y_pred = lm.predict(x)         # What does model predict for x? (orange line)
print(f"optimal_beta0 = {optimal_beta0:.3f}, optimal_beta1 = {optimal_beta1:.3f}")
print("y_pred", y_pred)
</pyeval>

Look what happens to the best (orange) fit line, as shown in [outlier]!  It has tilted substantially upwards towards the outlier. Because the loss function squares the error, an outlier can seriously distort the shape of the "bowl" and, hence, the minimum location of the optimal $\beta_0$ and $\beta_1$ coefficients.  Instead of $\beta_0=-0.170$ and $\beta_1 = 1.022$, the coefficients are $\beta_0=-13.150$ and $\beta_0=5.402$. All real data is noisy and sometimes outliers are common, which provides us with the motivation to regularize our linear models.

Let's try Ridge regularization. Using `sklearn` again, we can fit a new line through the data using Ridge regression:

<pyeval label=reg>
lm = Ridge(alpha=300)
lm.fit(x, y)
y_pred = lm.predict(x)
</pyeval>

<pyeval label=reg hide=true>
optimal_beta0 = lm.intercept_
optimal_beta1 = lm.coef_[0]
y_pred = lm.predict(x)         # What does model predict for x? (orange line)
print(f"optimal_beta0 = {optimal_beta0:.3f}, optimal_beta1 = {optimal_beta1:.3f}")
print("y_pred", y_pred)
</pyeval>

The `alpha=300` hyper parameter controls how much regularization we need, in this case a lot. (For those using TensorFlow's `keras` interface, you might use something like `activity_regularizer=regularizers.l2(300)` in one of your layers.)  While `sklearn` uses `alpha`, we will use $\lambda$ as the regularization hyper parameter as we get into the regularization penalty term of the loss function. Notice that the regularized slope, $\beta_1 = 1.369$, is very close to the unregularized $\beta_1 = 1.022$ without the outlier. With regularization, the orange fitted line is held back to an appropriate angle, as shown in [ridge].  Using Lasso regularization, `Lasso(alpha=45).fit(x, y)`, we'd get similar results.

The price we pay for keeping the angle sane, is a less accurate (biased) overall result than we saw for the unregularized model for non-outlier data.  The regularized $y$-intercept is larger, $\beta_0 = 7.02$, compared to unregularized $\beta_0=-0.17$ for the data without the outlier. You can see that the orange line rests above the majority of the data points instead of going through them. The outlier is still pulling the best fit line upward a little bit.

<sidefig caption="." label="outlier">	
	<img src="images/ols_outlier.svg" width="70%">
</sidefig>

<sidefig caption="." label="ridge">	
	<img src="images/ridge.svg" width="70%">
</sidefig>

<section title="The premise and trade-off of regularization">

We've motivated the need for regularization by showing how even a single outlier can seriously skew our model, but we still have no idea how regularization works.  Let's look at a real but small data set called [Ames housing price data](http://jse.amstat.org/v19n3/decock.pdf) ([ames.csv](code/ames.csv)) because it will point is in the direction of the solution. [ames_ols] shows a bar chart with one bar per coefficient using unregularized linear regression (with normalized explanatory variables and dummy-encoded categorical variables). Wow. Those are some big coefficients and, in fact, I had to clip them to slope magnitudes less than 1e8!  Contrast that with the Ridge-regularized coefficients in [ames_L2], which are in a much more reasonable range. The accuracy of the unregularized model is ridiculously bad, with an error of $9.1^{12}$ dollars on a 20% validation set. Using Ridge regression, however, the error is only about \$18k per house. With an average house price of about \$180k, that's only 10% error on the same validation set. (If you're an R^2 fan, the regularized validation R^2 is 0.84.)

That gives us the clue we need to arrive at the premise of regularization: **extreme coefficients are unlikely to yield models that generalize well.** The solution, therefore, is simply to constrain the magnitude of linear model coefficients so they don't get too big.  Constraining the coefficients means not allowing them to reach their optimal position, at the minimum loss location.  That means we pay a price for improved generality in the form of decreased accuracy (increase in bias). Recall what we observed in [ridge] where the orange line sat a bit above the majority of the data. This is a worthwhile trade because, as we can see from this example, unregulated models on real data sets don't generalize well (they have terrible accuracy on validation sets).

<sidefig caption="OLS regression coefficients; data was normalized, dummy-encoded categorical variables." label="ames_ols">	
	<img src="images/ames_ols.svg" width="100%">
</sidefig>

<sidefig caption="Ridge regression coefficients; data was  normalized, dummy-encoded categorical variables. 5-fold cross validation grid search used to identify best alpha value." label="ames_L2">	
	<img src="images/ames_L2.svg" width="100%">
</sidefig>

<section title="How regularization works conceptually">

At this point, we've set the stage: Regularization is important for model generalization and the idea behind regularization is simply to constrain coefficients, at a small cost in overall accuracy.   Now, let's figure out how regularization constrains coefficients, at least conceptually. (In a later section, we'll look at how regularization actually works in practice.) 

Take a look at the hypothetical loss function in [reg1beta], which is just $(\beta-2)^2$ for some $\beta$ coefficient. (In terms of high school $x$ and $y$, this is just $y= (x-2)^2$ or "a bowl shifted to 2".) The minimum loss is the bottom of the curve at $\beta = 2$. But, imagine we know that any coefficient bigger than 1.0 (or -1.0) will reduce generality. The best regularized coefficient is, therefore, $\beta = 1.0$, which is on the constraint  boundary in the direction of the minimum. By "best," we mean the closest we can get a coefficient to the loss function minimum location without exceeding our constraint.  

<sidefig caption="One coefficient regularization." label="reg1beta">	
	<img src="images/reg1D.svg" width="100%">
</sidefig>
<sidefig caption="Two coefficient regularization." label="reg2beta">	
	<img src="images/reg3D.svg" width="115%">
</sidefig>

If the loss function minimum were on the other side of the vertical axis at, say, $\beta=-2$ then the best regularized coefficient would be $\beta=-1$. We call this constraint of coefficients a *hard constraint* because the coefficients are strictly limited. (Foreshadowing, we actually implement these with soft constraints that just make bigger coefficients more and more expensive.) Mathematically, this hard constraint in one dimension is $|\beta| < t$, but we could also use $\beta^2 < t$ where $t$ represents the largest coefficient we want to allow ($t=1$ in this case). We use "less than" rather than "equal to" to cover the case where the minimum loss function location is within the constraint region.  In practice, we use a grid search to find the $t$ that gives the lowest validation error.

Now, let's consider the case where we have two coefficients to regularize instead of one (e.g., there are two variables in our explanatory matrix and we are not optimizing the $y$-intercept, $\beta_0$). Moving from one to two coefficients means the constraint line becomes a constraint region, and there are two common choices for the shape of this region. The first is a circle, which is used for Ridge, and the second is a diamond shape, which is used for Lasso. Ridge has some simpler properties, so let's take a look at it first.

<subsection title="L2 Ridge regularization">

[reg2beta] shows a hypothetical loss function with a minimum loss at $\beta_1=7$, $\beta_2=1$.  Surrounding the origin (0,0) there is a circular hard constraint that would prevent coefficients from reaching the minimum loss function location. The  best we could do would be coefficients on the constraint circle in the direction of the loss function minimum.  Constraining two coefficients to a circle of radius $r$ surrounding the origin means constraining the length of vector $(0,0) \rightarrow (\beta_1, \beta_2)$ to $r$. The length of a vector is just the square root of the sum of the elements, $\sqrt{\beta_1^2 + \beta_2^2} < r$. Or, we could get rid of the square root and pick some other constant, $t$, for the constraint: $\beta_1^2 + \beta_2^2 < t$. However we choose $t$, summing the square of coefficients sweeps out a circle on the coefficient plane. As in the one-variable case, in practice, we use a grid search to find the $t$ that gives the minimum validation error; the  value of $t$ itself is not really meaningful to us.

<aside title="Ridge = L2 regularization = weight decay">
Another way to say "vector length" is "vector norm" or "Euclidean distance between two points." It turns out there are lots of norms and mathematicians classify them as $L_1$ (which we'll see shortly), $L_2$, ..., $L_{\infty}$. The Euclidean distance / vector length is called the $L_2$ norm and that is why we call Ridge "$L_2$ regularization." The boundary is always at $t$ units away from the origin, sweeping out a circle. (See [L1 vs L2 norm](https://medium.com/@montjoile/l0-norm-l1-norm-l2-norm-l-infinity-norm-7a7d18a4f40c) for an easy to read discussion.)

While we're talking about names, L2 regression was called "Ridge" in the [original paper](https://www.math.arizona.edu/~hzhang/math574m/Read/RidgeRegressionBiasedEstimationForNonorthogonalProblems.pdf) from 1970 because the author remarked that surface plots of quadratic functions often look like ridges. 

Also, L2 regularization (penalizing loss functions with sum of squares) is called *weight decay* in deep learning neural networks.
</aside>

To get a feel for L2 regularization, look at the hypothetical loss functions in [L2dir], where I have projected the 3D loss "bowl" function onto the plane so we're looking at it from above. The big black dot indicates the ($\beta_1,\beta_2$) coordinate where the loss of function is minimum (bottom of the bowl). The big red dot is the ($\beta_1,\beta_2$) point on the boundary closest to the optimal loss function location subject to the circular L2 constraint. 

<figure label="L2dir" caption="blort">
<table>
<tr><th>(a)<th>(b)<th>(c)<th>(d)
<tr>
	<td><img src="images/l2-symmetric-0.svg" width="100%">
	<td><img src="images/l2-symmetric-1.svg" width="100%">
	<td><img src="images/l2-symmetric-2.svg" width="100%">
	<td><img src="images/l2-symmetric-3.svg" width="100%">
</table>
</figure>

All of these loss functions are symmetric, like your morning cereal bowl, which makes it easy to identify where the regularized ($\beta_1,\beta_2$) sits on the boundary circle. For symmetric loss functions, draw a line from the origin to the minimum loss function location, indicated by the dashed line in [L2dir]. The optimal regularized ($\beta_1,\beta_2$) coefficients are at the intersection of that line and the boundary.  

Although I don't show it here, if the minimum loss function location sits within the boundary region, then the regularized location is exactly the same as the minimum loss location. (That's why we use $<t$ rather than $=t$.) Another special case is when the minimum loss location sits on one of the axes, as in [L2dir] (b).  In this case, one of the regularized coefficients will also sit on the axis and, hence, one of the coefficients will be zero. We will talk a lot about zero coefficients later when comparing Ridge and Lasso.

In general, the loss functions will not be symmetric and look more like those depicted in [L2nonsym]. Identifying the regularized coefficients on the boundary circle is not as simple as drawing a line between the origin and the minimum loss location, such as in [L2nonsym] (a). (I'm sure in a non-Euclidean space, such as one warped by gravity, we could draw a "straight" line; is there an algebraic topologist in the house?) Now, the approach is to identify the location of minimum loss that sits directly on the boundary circle. That is exactly how I plotted the location of the red dots in these figures. I computed the loss function value at many points along the circle and simply identified the location where the loss function was the smallest. This is really important and so let's make a big deal out of it:

**Finding the L2 coefficients location**: The L2 regularized coefficients sit on the L2 boundary circle where the loss function has the minimum value. So, just walk around the circle and identify the location with the minimum loss function value. (Unless the minimum loss location is inside the circle, in which case the regularized coefficient location is the same as the minimum loss location.)

I see instructors and articles recommend students look for where a loss function contour line touches the boundary region, but this can get you in trouble.  The contour maps are a 2D projection of a smooth 3D surface and so the number and location contour lines are kind of arbitrary. For example, I chose the number of contour lines in these plots, but I could've chosen one third as many. With few contour lines, it would be challenging to find a contour line that intersected the boundary circle.  Except for [L2nonsym] (a), the regularized coefficient location does not sit where a contour line meets the constraints circle. It's better to stick with finding the minimum loss location on the boundary circle and try not to get clever with visual rules, at least until you have more experience.

<figure label="L2nonsym" caption="blort">
<table>
<tr><th>(a)<th>(b)<th>(c)<th>(d)
<tr>
	<td><img src="images/l2-0.svg" width="100%">
	<td><img src="images/l2-1.svg" width="100%">
	<td><img src="images/l2-2.svg" width="100%">
	<td><img src="images/l2-3.svg" width="100%">
</table>
</figure>

Let's look at the mathematics now. Regularizing our MSE loss function is a simple matter of adding a "subject to" constraint to the definition, in this case, L2 norm $\beta_1^2 + \beta_2^2 < t$:

\[
MSE(\beta_0,\beta_1,t) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - (\beta_0 + \beta_1 x_1^{(i)} + \beta_2 x_2^{(i)}))^2 \text{ subject to } (\beta_1^2 + \beta_2^2) < t
\]

Everything to the left of "subject to" is identical to the unregularized two-variable linear-model (MSE) loss function: $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2$. All we've done is to constrain how close ($\beta_1,\beta_2$) coefficients can get to the loss function minimum location.  Note that we do not constrain the $y$-intercept $\beta_0$ (see page 64 in "*The elements of statistical learning*"). We are only concerned with constraining slope angles, not where the line touches the $y$-axis. We find the value of $t$ using a brute force search that minimizes the validation error.

That's all there is to the concept of regularization: adding a hard constraint to the loss function equation. Congratulations, if you've gotten this far and understood everything! If all you care about is L2 Ridge regularization, the only thing left to consider is how we actually implement regularization, which we'll do in [impl].

Now, let's take a look at the other common form of regularization.

<subsection title="L1 Lasso regularization">

If we use a diamond shape rather than a circle around the origin as the boundary region, we get *Lasso regularization*, which we will call L1 regularization because it constrains $\beta_i$ coefficients using the L1 norm. The L1 norm gives us a diamond shape, obtained by constraining the sum of coefficient magnitudes to some constant, $t$. (L2 Ridge constrains the sum of the square of coefficient magnitudes.) Lasso stands for "Least Absolute Shrinkage and Selection Operator," according to the [original paper](http://www-stat.stanford.edu/~tibs/lasso/lasso.pdf). Why we would choose a diamond over a circle will become clear shortly.
	
The plots in [L1symm] show the L1 diamond constraint regions in the special case where the loss function is symmetric. The regularized ($\beta_1,\beta_2$) coefficient location on the diamond occurs where a perpendicular line emanates from the diamond to the minimum loss location. The dotted lines in [L1symm] show these perpendicular lines. Contrast this with L2 regularization, which draws a line from the origin to the minimum loss location for symmetric loss functions.

<figure label="L1symm" caption=" boundary distance from origin is some of coefficient magnitudes less than some constant, t.">
<table>
<tr><th>(a)<th>(b)<th>(c)<th>(d)
<tr>
	<td><img src="images/l1-symmetric-0.svg" width="100%">
	<td><img src="images/l1-symmetric-1.svg" width="100%">
	<td><img src="images/l1-symmetric-2.svg" width="100%">
	<td><img src="images/l1-symmetric-3.svg" width="100%">
</table>
</figure>

In [L1asymm], you'll see the general case where the loss functions are asymmetric. One of the key takeaways from these examples is that three out of four loss functions have a zero coefficient (the red dot is on an axis at a diamond peak). This is despite the fact that the minimum loss function locations look to be nowhere near an axis, which brings us to the difference between L1 and L2 in a nutshell: **L1 tends to give a lot more zero coefficients than L2**.

<figure label="L1asymm" caption="blort">
<table>
<tr><th>(a)<th>(b)<th>(c)<th>(d)
<tr>
	<td><img src="images/l1-0.svg" width="100%">
	<td><img src="images/l1-1.svg" width="100%">
	<td><img src="images/l1-2.svg" width="100%">
	<td><img src="images/l1-3.svg" width="100%">
</table>
</figure>

To find regularized coefficients, we follow the same rule we did for L2, except using a different boundary shape:
 
**Finding the L1 coefficients location**: The L1 regularized coefficients sit on the L1 boundary diamond where the loss function has the minimum value. So, just walk around the diamond and identify the location with the minimum loss function value. (Unless the minimum loss location is inside the diamond, in which case the regularized coefficient location is the same as the minimum loss location.)

Just as we did for L2, regularizing the loss function means adding a "subject to" constraint. The only difference is that we are summing the coefficient magnitudes (absolute values) rather than the squared coefficient values:

\[
MSE(\beta_0,\beta_1,t) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - (\beta_0 + \beta_1 x_1^{(i)} + \beta_2 x_2^{(i)}))^2 \text{ subject to } (|\beta_1| + |\beta_2|) < t
\]

As before, we don't care what the value of $t$ is *per se*; we find the $t$ through brute force that gives the lowest validation error.

If you've made it this far, you now understand exactly how L1 Lasso and L2 Ridge regularization work conceptually. The next step is to compare the two in detail and then we'll be ready to describe the actual implementation of regularization (versus the conceptual mechanism we've seen so far).

<aside title="The Ridge and Lasso terms seem backwards">
In case you haven't noticed, the Ridge and Lasso terms seem kind of backwards. The circular boundary of Ridge looks more like a lasso and the constraint region for Lasso, with lots of pointy discontinuities, looks like a bunch of ridges. Ha! For more good-natured teasing of statisticians, see [Statisticians say the darndest things](https://explained.ai/statspeak/index.html).
</aside>

<section title="The difference between L1 and L2 regularization">

If both of these regularization techniques work well, you might be wondering why we need both. It turns out they have different but equally useful properties. From a practical standpoint, L1 tends to shrink coefficients to zero whereas L2 tends to shrink coefficients evenly. L1 is therefore useful for feature selection, as we can drop any variables associated with coefficients that go to zero. L2, on the other hand, is useful when you have collinear/codependent features. (An example pair of codependent features is `gender` and `ispregnant` since, at the current level of medical technology, only females can be `ispregnant`.) Codependence tends to increase coefficient variance, making coefficients unreliable/unstable, which hurts model  generality. L2 reduces the variance of these estimates, which counteracts the effect of codependencies.

<subsection title="L1 regularization encourages zero coefficients">

One of the key questions that I want to answer is: "*Does L1 encourage model coefficients to shrink to zero?*" (The answer is, Yes!) So, let's do some two-variable simulations of random quadratic loss functions at random locations and see how many end up with a coefficient at zero. There is no guarantee that these random paraboloid loss functions in any way represent real data sets, but it's a way to at least compare L1 and L2 regularization. Let's start out with symmetric loss functions, which look like bowls of various sizes and locations, and compare how many zero coefficients appear for L1 and L2 regularization:

<table>
<tr>
	<td><img src="images/l1-symmetric-cloud.png" width="65%">
	<td><img src="images/l2-symmetric-cloud.png" width="65%">
</table>

Green dots represent a random loss function that resulted in a  regularized coefficient being zero. Blue represents a random loss function where no regularized coefficient was zero (North, South, East, West compass points). Orange represents loss functions in L2 plots that had at least one coefficient close to zero (within 10% of the max distance of any coefficent pair.) As you can see in the simulations (5000 trials), the L1 diamond constraint zeros a coefficient for any loss function whose minimum is in the zone perpendicular to the diamond edges. The L2 circular constraint only zeros a coefficient for loss function minimums sitting really close to or on one of the axes. The orange zone indicates where L2 regularization gets close to a zero for a random loss function. Clearly, L1 gives many more zero coefficients (66%) than L2 (3%) for symmetric loss functions.

In the more general case, loss functions can be asymmetric and at an angle, which results in more zeros for L1 and slightly more zeros for L2:

<table>
<tr>
	<td><img src="images/l1-cloud.png" width="65%">
	<td><img src="images/l2-cloud.png" width="65%">
</table>

Because of the various angles and shapes, such as we saw in [L2nonsym], more of the regularized coefficients for both L1 (72%) and L2 (5%) constraints become zero.  Also notice that there are a number of orange dots not clustered around the axes for L2; they are more spread out than for symmetric loss functions.  This might not be a perfect simulation, I think it's good enough to get our answer: *Yes, L1 regularized coefficients are much more likely to become zeros than L2 coefficients.*

<subsection title="L1 and L2 regularization encourage zero coefficients for less predictive features">

On the other hand, we actually want to answer a more specific question: "*Does L1 encourage zero coefficients for less predictive or useless features?*" To answer that, we need to know what  loss functions look like for less predictive features. Imagine one of two features is very important and the other is not. That would imply that the loss function looks like a taco shell or canoe, and at or close to 90 degrees to one of the axes. [L1ortho] shows some examples for the L1 constraint. If $\beta_1$ is not very predictive, as in (b)(c)(d), then movement left and right does not increase the cost very much, whereas, moving up and down costs a lot (we're crossing a lot of contour lines). If $\beta_2$ is not very predictive, as in (a), then changing $\beta_2$ does not cost very much but moving left and right with $\beta_1$ does, because we are crossing contour lines again.

<figure label="L1ortho" caption="blort">
<table>
<tr><th>(a)<th>(b)<th>(c)<th>(d)
<tr>
	<td><img src="images/l1-orthogonal-0.svg" width="100%">
	<td><img src="images/l1-orthogonal-1.svg" width="100%">
	<td><img src="images/l1-orthogonal-2.svg" width="100%">
	<td><img src="images/l1-orthogonal-3.svg" width="100%">
</table>
</figure>

With the shape of those orthogonal loss functions in mind, let's do another simulation and see how many regularized coefficients go to zero:

<table>
<tr>
	<td><img src="images/l1-orthogonal-cloud.png" width="65%">
	<td><img src="images/l2-orthogonal-cloud.png" width="65%">
</table>

Orthogonal loss functions result in more zero coefficients than the general case, which is what we would expect, but the effect is not huge; 72% to 80%. L2, on the other hand, sees a huge boost in the number of zero coefficients, from 5% to 45%!  We definitely want more zero coefficients for the case where one of the features is less predictive.  Fortunately, both L1 and L2 deliver in this case! 

A more scientific approach would also do simulations for the many variable case, but I think this article provides enough evidence for me to believe L1 encourages zeros. Besides, James D. Wilson, a statistician and fellow faculty member, told me there's a theorem that says that the probability of a coefficient going to zero approaches 100% as the number of features goes to infinity. Apparently, as the number of features goes to infinity, the diamond-shaped collapses in on itself to a point.


<aside title="Random loss functions used in simulation" label="foo">
For math nerds, this is the equation used to generate the random loss functions:

\[
loss = a (\beta_1 - c_1)^2 + b(\beta_2 - c_2)^2 + c(\beta_1 - c_1)(\beta_2 - c_2)
\]

where $a \sim U(0,10)$ scales the bowl in the $\beta_1$ direction, $b \sim U(0,10)$ scales the $\beta_2$ direction, $c \sim U(-2,2)$ controls the amount of tilt/angle away from vertical or horizontal, and ($c_1 \sim U(-10,10)$,$c_2 \sim U(-10,10)$) is the position in coefficient space of the minimum loss function value. $U(k,l)$ means uniform random variable between $k$ and $l$.
</aside>

<section title="How we implement L1 and L2 regularization" label="impl">

	foo

**Acknowledgements**. I'd like to thank mathematicians Steve Devlin and David Uminsky, also faculty in [University of San Francisco's MS in Data Science program](https://www.usfca.edu/arts-sciences/graduate-programs/data-science), for helping me understand the mathematics and why L1 regularization encourages zero coefficients.

<section title="Resources">

My MSDS621 project [Using gradient descent to fit regularized linear models](https://github.com/parrt/msds621/raw/master/projects/linreg/linreg.pdf)

	[Deep Learning Basics Lecture 3: Regularization I (slides)](https://www.cs.princeton.edu/courses/archive/spring16/cos495/slides/DL_lecture3_regularization_I.pdf) by Yingyu Liang at  Princeton University.
	
[Regularized Regression](https://uc-r.github.io/regularized_regression) from University of Cincinnati.

[Lecture notes on ridge regression](https://arxiv.org/pdf/1509.09169.pdf) by Wessel N. van Wieringen.

[Ridge Regression: Biased Estimation for Nonorthogonal Problems](https://www.math.arizona.edu/~hzhang/math574m/Read/RidgeRegressionBiasedEstimationForNonorthogonalProblems.pdf) by Hoerl and Kennard, Journal Technometrics, 1970.

[Regression Shrinkage and Selection via the Lasso](http://www-stat.stanford.edu/~tibs/lasso/lasso.pdf) by Tibshirani in Journal of the Royal Statistical Society, 1996.